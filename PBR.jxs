<jittershader name="PBR">
	<description>a physical-based rendering shader </description>
	<param name="pos" 	type="vec3" state="POSITION" />
	<param name="nor" 	type="vec3" state="NORMAL" />
	<param name="tan" 	type="vec3" state="TANGENT" />
	<param name="bit" 	type="vec3" state="BITANGENT" />
	<param name="uv" 	type="vec2" state="TEXCOORD" />
	<param name="MVP" 	type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="MV"	type="mat4" state="MODELVIEW_MATRIX" />
	<param name="M" 	type="mat4" state="WORLD_MATRIX" />
	<param name="NM"	type="mat3" state="NORMAL_MATRIX" />
	<param name="eye" 	type="vec3" state="CAMERA_POSITION" />
	//textures
	<param name="albedoTex" 	type="int" default="0" />
	<param name="normalTex" 	type="int" default="1" />
	<param name="RMOHTex" 		type="int" default="2" />
	<param name="irradianceTex"	type="int" default="3" />
	<param name="equirectTex"	type="int" default="4" />
	<param name="integMap"		type="int" default="5" />
	<texture file="ibl_brdf_lut.png" type="float16" unit="5" rectangle="0" filter="none none" wrap="repeat repeat"/>

	<param name="texRepeat" 			type="vec2" default="1. 1." />
	<param name="heightScale"			type="float" default="0.08" />
	<param name="triplanarUV"   		type="float" default="0." />
	<param name="triplanarExp"  		type="float" default="12." />
	<param name="triplanarTexRepeat" 	type="vec2" default="0.5 0.5" />

	<language name="glsl" version="1.5">
		<bind param="pos" 	program="vp" />
		<bind param="nor" 	program="vp" />
		<bind param="tan" 	program="vp" />
		<bind param="bit" 	program="vp" />
		<bind param="uv" 	program="vp" />
		<bind param="MVP" 	program="vp" />
		<bind param="MV"	program="vp" />
		<bind param="M" 	program="vp" />
		<bind param="NM"	program="vp" />
		<bind param="eye" 	program="fp" />
		//textures
		<bind param="albedoTex" 	program="fp" />
		<bind param="normalTex" 	program="fp" />
		<bind param="RMOHTex" 		program="fp" />
		<bind param="irradianceTex" program="fp" />
		<bind param="equirectTex"   program="fp" />
		<bind param="integMap"      program="fp" />

		<bind param="texRepeat"				program="vp" />
		<bind param="heightScale"   		program="fp" />
		<bind param="triplanarUV"   		program="fp" />
		<bind param="triplanarExp"			program="fp" />
		<bind param="triplanarTexRepeat" 	program="fp" />

		<program name="vp" type="vertex">
<![CDATA[
#version 330 core
uniform mat4 MVP, MV, M;
uniform mat3 NM;
uniform vec2 texRepeat;
in vec3 pos, nor, tan, bit;
in vec2 uv;

out jit_PerVertex {	
	smooth 	vec3 nor;
	smooth 	vec3 tan;
	smooth 	vec3 bit;
	smooth 	vec3 pos;
	smooth 	vec2 uv;
	flat 	vec2 texRepeat;
	smooth 	vec3 eyePos;
	smooth  vec3 modelPos;
	smooth  vec3 modelNor;
	smooth  mat3 TBN;
	smooth  mat3 transTBN;
} jit_out;

void main() {	

	gl_Position = MVP * vec4(pos, 1.);	
	jit_out.nor = (M * vec4(nor, 0.)).xyz;
	jit_out.tan = (M * vec4(tan, 0.)).xyz;
	//jit_out.tan = normalize(jit_out.tan - dot(jit_out.tan, jit_out.nor) * jit_out.nor);
	jit_out.bit = -cross(jit_out.nor, jit_out.tan);
	jit_out.pos = (M * vec4(pos, 1.)).xyz;
	jit_out.uv = uv*texRepeat;
	jit_out.texRepeat = texRepeat;
	jit_out.eyePos = (MV * vec4(pos, 1.)).xyz;
	jit_out.modelPos = pos;
	jit_out.modelNor = nor;
	jit_out.TBN = mat3(jit_out.tan, jit_out.bit, jit_out.nor);
	jit_out.transTBN = transpose(jit_out.TBN);
}
]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[
#version 330 core
#define PI 3.14159265

uniform vec3 eye;
uniform sampler2D albedoTex, normalTex, RMOHTex, equirectTex, integMap;
uniform samplerCube irradianceTex;
uniform float heightScale, triplanarUV, triplanarExp;
uniform vec2 triplanarTexRepeat;

in jit_PerVertex {
	smooth 	vec3 nor;
	smooth 	vec3 tan;
	smooth 	vec3 bit;
	smooth 	vec3 pos;
	smooth 	vec2 uv;	
	flat 	vec2 texRepeat;
	smooth  vec3 eyePos;
	smooth  vec3 modelPos;
	smooth  vec3 modelNor;
	smooth  mat3 TBN;
	smooth  mat3 transTBN;
} jit_in;

out vec4 col;

//utilities
vec3 	lin2sRGB(vec3 x){ return pow(x, vec3(0.4545454545));}
vec3 	sRGB2lin(vec3 x){ return pow(x, vec3(2.2));}
float 	saturate(float x){ return clamp(x, 0., 1.);}
vec3 	saturate3(vec3 x){ return clamp(x, vec3(0.), vec3(1.));}
vec2 dir2uv(vec3 v){
    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
    uv *= vec2(-0.1591, 0.3183); //to invert atan
    uv += 0.5;
    return uv;
}

//triplanar mapping
vec4 triplanar(sampler2D tex){

	vec3 	k = normalize(pow(abs(jit_in.modelNor), vec3(triplanarExp)));
	vec2 	Xuv = jit_in.modelPos.yz*triplanarTexRepeat;
			Xuv.x = jit_in.modelNor.x < 0. ? Xuv.x : -Xuv.x;
	vec2 	Yuv = jit_in.modelPos.xz*triplanarTexRepeat;
			Yuv.x = jit_in.modelNor.y < 0. ? Yuv.x : -Yuv.x;
	vec2 	Zuv = jit_in.modelPos.xy*triplanarTexRepeat;
			Zuv.x = jit_in.modelNor.z >= 0. ? Zuv.x : -Zuv.x;
			Xuv.y += 0.5;
			Zuv.x += 0.5;
	vec4 	X = texture(tex, Xuv)*k.x;
	vec4 	Y = texture(tex, Yuv)*k.y;
	vec4 	Z = texture(tex, Zuv)*k.z;
	return 	(X+Y+Z)/(k.x+k.y+k.z);
}
vec4 triplanarAlb(sampler2D tex){

	vec3 	k = normalize(pow(abs(jit_in.modelNor), vec3(triplanarExp)));
	vec2 	Xuv = jit_in.modelPos.yz*triplanarTexRepeat;
			Xuv.x = jit_in.modelNor.x < 0. ? Xuv.x : -Xuv.x;
	vec2 	Yuv = jit_in.modelPos.xz*triplanarTexRepeat;
			Yuv.x = jit_in.modelNor.y < 0. ? Yuv.x : -Yuv.x;
	vec2 	Zuv = jit_in.modelPos.xy*triplanarTexRepeat;
			Zuv.x = jit_in.modelNor.z >= 0. ? Zuv.x : -Zuv.x;
			Xuv.y += 0.5;
			Zuv.x += 0.5;
	vec4 	X = texture(tex, Xuv);
			X.rgb = sRGB2lin(X.rgb);
			X *= k.x;
	vec4 	Y = texture(tex, Yuv);
			Y.rgb = sRGB2lin(Y.rgb);
			Y *= k.y;
	vec4 	Z = texture(tex, Zuv);
			Z.rgb = sRGB2lin(Z.rgb);
			Z *= k.z;
	return 	(X+Y+Z)/(k.x+k.y+k.z);
}
//Parallax mapping
vec3 parallaxMapping(vec2 T, vec3 V, vec2 texRepeat){
	//compute texture coordinates ratio
	float uvRatio = texRepeat.x / texRepeat.y;
	V.x *= uvRatio;

   	// determine optimal number of layers
   	const float minLayers = 300;
   	const float maxLayers = 300;
   	float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0, 0, 1), V)));

   	// height of each layer
   	float layerHeight = 1.0 / numLayers;
   	// current depth of the layer
   	float curLayerHeight = 0;
   	// shift of texture coordinates for each layer
   	vec2 dtex = heightScale * V.xy / V.z / numLayers;

   	// current texture coordinates
   	vec2 currentTextureCoords = T;

   	float lod = 0.;//( 1. - abs(dot(vec3(0, 0, 1), V)))*0.;

  	// depth from heightmap
   	float heightFromTexture = 1. - textureLod(RMOHTex, currentTextureCoords, lod).a;

   	// while point is above the surface
   	while(heightFromTexture > curLayerHeight) 
   	{
      	// to the next layer
      	curLayerHeight += layerHeight; 
      	// shift of texture coordinates
      	currentTextureCoords -= dtex;
      	// new depth from heightmap
      	heightFromTexture = 1. - textureLod(RMOHTex, currentTextureCoords, lod).a;
   	}

   	///////////////////////////////////////////////////////////

   	// previous texture coordinates
   	vec2 prevTCoords = currentTextureCoords + dtex;

   	// heights for linear interpolation
   	float nextH = heightFromTexture - curLayerHeight;
   	float prevH = 1. - textureLod(RMOHTex, prevTCoords, lod).a
                           - curLayerHeight + layerHeight;

   	// proportions for linear interpolation
   	float weight = nextH / (nextH - prevH);

   	// interpolation of texture coordinates
   	vec2 finalTexCoords = prevTCoords * weight + currentTextureCoords * (1.0-weight);

   	// interpolation of depth values
   	// curLayerHeight + prevH * weight + nextH * (1.0 - weight);

   	// return result
   	return vec3(finalTexCoords, curLayerHeight + prevH * weight + nextH * (1.0 - weight));
}
float shadow(vec3 L, vec3 N, vec2 initialTexCoord, float initialHeight){



   // calculate lighting only for surface oriented to the light source
   float NdotL = dot(N, L);
   if(NdotL < 0.0) {return 0.;}

   const float minLayers = 200;
   const float maxLayers = 200;

    // calculate initial parameters
    float numSamplesUnderSurface = 0.;
    float shadowMultiplier = 0.;
    float numLayers = mix(maxLayers, minLayers, abs(NdotL));
    float layerHeight = initialHeight / numLayers;
    vec2 texStep = heightScale * L.xy / L.z / numLayers;

    // current parameters
    float currentLayerHeight = initialHeight - layerHeight;
    vec2 currentTextureCoords = initialTexCoord + texStep;
    float heightFromTexture = 1. - texture(RMOHTex, currentTextureCoords).a;
    float stepIndex = 1.;

    //int count = 0;

    // while point is below depth 0.0 )
    while(currentLayerHeight > 0.){

        // if point is under the surface
        if(heightFromTexture < currentLayerHeight){

            // calculate partial shadowing factor
            numSamplesUnderSurface += 1.;
            float newShadowMultiplier = (currentLayerHeight  - heightFromTexture)*(1.0 - stepIndex / numLayers);
            shadowMultiplier = max(shadowMultiplier, newShadowMultiplier);
        }

        // offset to the next layer
        stepIndex += 1.;
        currentLayerHeight -= layerHeight;
        currentTextureCoords += texStep;
        heightFromTexture = 1. - texture(RMOHTex, currentTextureCoords).a;
        //count += 1;
    }

    // Shadowing factor should be 1 if there were no points under the surface
    return (numSamplesUnderSurface <= 1.) ? 1. : 1. - saturate(shadowMultiplier*30);
    //return abs(NdotL);
}
//PBR functions
vec3 fresnelSchlickRoughness(float HdotV, vec3 F0, float rou){
	float 	x = saturate(1. - HdotV); //x^5
	float 	x2 = x*x;
			x2 *= x2;
			x *= x2;
    return F0 + (max(vec3(1.0 - rou), F0) - F0) * x;
} 
float DistributionGGX(float NdotH, float rou){
			rou *= rou; //Disney trick!
			rou *= rou; //roughness^4
     		NdotH *= NdotH; //square the dot product
    float 	denom = (NdotH * (rou - 1.0) + 1.0);
    		denom *= denom;
    		denom *= PI;
	
    return 	rou / denom;
}
float GeometrySchlickGGX(float NdotV, float rou){
			rou += 1.;
    float 	k = (rou*rou) / 8.0; //Disney trick again...
    return NdotV / ( NdotV * (1.0 - k) + k );
}
float GeometrySmith(float NdotV, float NdotL, float rou){
    float ggx2  = GeometrySchlickGGX(NdotV, rou);
    float ggx1  = GeometrySchlickGGX(NdotL, rou);
	
    return ggx1 * ggx2;
} 
vec3 getRadiance(vec3 V, vec3 N, vec3 L, vec3 rad, vec3 pos, vec3 alb, float rou, float met){

	//vec3	L = normalize(lig - pos);				//light direction
	vec3	H = normalize(V + L);					//half vector
	//float	ligDis = length(lig - pos);		
	//float	att = 1. / (ligDis*ligDis);				//light attenuation
	//vec3	rad = ligCol * att;						//radiance

	//compute dot products
	float	HdotV = saturate(dot(H, V));
    float 	NdotV = saturate(dot(N, V)) + 0.001; //avoid deviding by 0
    float 	NdotL = saturate(dot(N, L));
    float   NdotH = saturate(dot(N, H));

	vec3 	F0 	= vec3(0.04); 						//dialettric F0
			F0 	= mix(F0, alb, vec3(met));			//use alb as F0 if metallic
	vec3 	F  	= fresnelSchlickRoughness(HdotV, F0, rou); 		//compute fresnel
	float	NDF = DistributionGGX(NdotH, rou);   	//compute NDF term
	float 	G   = GeometrySmith(NdotV, NdotL, rou); //compute G term   
	vec3 	spe = (NDF*G*F)/(4.*NdotV*NdotL+0.0001);  

	vec3 	kS = F;					//k specular
	vec3 	kD = vec3(1.0) - kS;	//k diffuse
			kD *= 1.0 - met;		//nullify k diffuse if metallic

	return 	(kD * alb / PI + spe) * rad * NdotL;
}
		
vec3	pointLight(	vec3 lig, vec3 ligCol, vec3 V, vec3 N, vec3 tanN, vec3 pos, vec2 uv, float height, vec3 alb, float rou, float met){
		
	vec3	ligMinPos 	= lig - pos;
	float	ligDis 		= length(ligMinPos);	
	vec3	L 			= ligMinPos/ligDis;				//light direction
	vec3	rad 		= ligCol / (ligDis*ligDis);						//radiance
	vec3	tanLigDir 	= normalize(jit_in.transTBN * ligMinPos);	//light pos in tangent space
	bool	compute 	= rad.x+rad.y+rad.z > 0.05;
	return  compute ? 	shadow(tanLigDir, tanN, uv, height) * 
						getRadiance(V, N, L, rad, pos, alb, rou, met) :
						vec3(0.); //get radiance for this light
}	
vec3	directionalLight(	vec3 ligDir, vec3 ligCol, vec3 V, vec3 N, vec3 tanN, vec3 pos, vec2 uv, float height, vec3 alb, float rou, float met){
	
	vec3	tanLigDir 	= normalize(jit_in.transTBN * ligDir);	//light pos in tangent space
	return  shadow(tanLigDir, tanN, uv, height) * 
			getRadiance(V, N, ligDir, ligCol, pos, alb, rou, met); //get radiance for this light
}		
vec3 ACES(vec3 x){	
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return saturate3((x*(a*x+b))/(x*(c*x+d)+e));
}
void main() {

	//prepare parallax mapping
	vec3	tanV 		= normalize(jit_in.transTBN * (eye - jit_in.pos));		//tangent view direction
	vec3 	uvHeight 	= parallaxMapping(jit_in.uv, tanV, jit_in.texRepeat);	//texture coordinates
	vec2	uv 			= uvHeight.xy;
	float	height 		= uvHeight.z;
	
	if(uv.x > jit_in.texRepeat.x || uv.y > jit_in.texRepeat.y || uv.x < 0.0 || uv.y < 0.0){discard; }

	bool	triplanarTexturing = triplanarUV == 1.;

	vec3 	alb = 	triplanarTexturing ? triplanarAlb(albedoTex).rgb 	: sRGB2lin(texture(albedoTex, uv).rgb);	//albedo color	
	vec4	RMOH = 	triplanarTexturing ? triplanar(RMOHTex) 			: texture(RMOHTex, uv);			//roughness
	float	rou = 	RMOH.r;			//roughness
	float	met = 	RMOH.g;			//metallic
	float	occ = 	RMOH.b;			//ambient occlusion

	vec3	V 		= normalize(eye - jit_in.pos);				//view direction
	vec3	tanN 	= triplanarTexturing ? triplanar(normalTex).rgb : texture(normalTex, uv).rgb; 			//normals
			tanN 	*= 2.;
			tanN 	-= 1.;
			tanN 	= normalize(tanN);
	vec3	N 		= normalize(jit_in.TBN * tanN);

	vec3	radiance = vec3(0.);								//initialize the out color to 0

	//lighting
	{
		vec3	lig 		= vec3(1., 3., 0.);					//light position
		vec3	ligCol 		= vec3(1.)*9.;
				radiance 	+= pointLight(lig, ligCol, V, N, tanN, jit_in.pos, uv, height, alb, rou, met);
	}
	{
		vec3	lig 		= vec3(-2., 1., -1.);				//light position
		vec3	ligCol 		= vec3(0.8, 0.5, 0.1)*9.;
				radiance 	+= pointLight(lig, ligCol, V, N, tanN, jit_in.pos, uv, height, alb, rou, met);
	}
	{
		vec3	lig 		= vec3(2., -1., 1.);				//light position
		vec3	ligCol 		= vec3(0.1, 0.5, 0.9)*9.;
				radiance 	+= pointLight(lig, ligCol, V, N, tanN, jit_in.pos, uv, height, alb, rou, met);
	}
	{
		vec3	lig 		= vec3(-2., -1., -2.);				//light position
		vec3	ligCol 		= vec3(1.)*9.;	
				radiance 	+= pointLight(lig, ligCol, V, N, tanN, jit_in.pos, uv, height, alb, rou, met);
	}
	{
		vec3	ligDir 		= normalize(vec3(0., 1., 0.));		//light direction
		vec3	ligCol 		= vec3(1.)*9.;	
				radiance 	+= directionalLight(ligDir, ligCol, V, N, tanN, jit_in.pos, uv, height, alb, rou, met);
	}

	vec3 	F0 	= vec3(0.02); 						//dialettric F0
			F0 	= mix(F0, alb, vec3(met));			//use alb as F0 if metallic
	float	NdotV = max(dot(N, V), 0.);
	vec3 	kS = fresnelSchlickRoughness(NdotV, F0, rou);
	vec3 	kD = vec3(1.) - kS;
			kD *= 1. - met;
	vec3 	irradiance = texture(irradianceTex, N).rgb;
	vec3	diffuse = irradiance * alb * kD;

	float 	lod             	= rou*6.;
	vec3	ref 				= reflect(-V, N);
	vec3 	prefilteredColor 	= texture(equirectTex, dir2uv(ref), lod).rgb;
	vec2 	envBRDF          	= texture(integMap, vec2(NdotV, rou)).xy;
 	vec3 	specular 			= prefilteredColor * (kS * envBRDF.x + envBRDF.y); 

	vec3 	ambient = (diffuse + specular) * occ; 

 			col.rgb = radiance + ambient; //put this one back!!!!
 			//col.rgb = specular;
 			//col.rgb = radiance;
 			//col.rgb = irradiance;

 			//gamma corrections
			col.rgb /= col.rgb + vec3(1.); 		//from HDI lo LDI
			//lin = ACES(lin);
			col.rgb = lin2sRGB(col.rgb);	//gamma correction
			col.a = 1.;

}	
]]>
		</program>
	</language>
</jittershader>
