<jittershader name="PBR">
	<description>a physical-based rendering shader </description>
	<param name="pos" 	type="vec3" state="POSITION" />
	<param name="nor" 	type="vec3" state="NORMAL" />
	<param name="tan" 	type="vec3" state="TANGENT" />
	<param name="uv" 	type="vec2" state="TEXCOORD" />
	<param name="MVP" 	type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="M" 	type="mat4" state="WORLD_MATRIX" />
	<param name="NM"	type="mat3" state="NORMAL_MATRIX" />
	<param name="eye" 	type="vec3" state="CAMERA_POSITION" />
	//textures
	<param name="albedoTex" 	type="int" default="0" />
	<param name="roughnessTex" 	type="int" default="1" />
	<param name="metallicTex" 	type="int" default="2" />
	<param name="normalTex" 	type="int" default="3" />
	<param name="aoTex" 		type="int" default="4" />
	<param name="irradianceTex"	type="int" default="5" />

	<param name="texRepeat" 	type="vec2" default="1. 2." />

	<language name="glsl" version="1.5">
		<bind param="pos" 	program="vp" />
		<bind param="nor" 	program="vp" />
		<bind param="tan" 	program="vp" />
		<bind param="uv" 	program="vp" />
		<bind param="MVP" 	program="vp" />
		<bind param="M" 	program="vp" />
		<bind param="NM"	program="fp" />
		<bind param="eye" 	program="fp" />
		//textures
		<bind param="albedoTex" 	program="fp" />
		<bind param="roughnessTex" 	program="fp" />
		<bind param="metallicTex" 	program="fp" />
		<bind param="normalTex" 	program="fp" />
		<bind param="aoTex" 		program="fp" />
		<bind param="irradianceTex" program="fp" />

		<bind param="texRepeat"		program="vp" />

		<program name="vp" type="vertex">
<![CDATA[
#version 330 core
uniform mat4 MVP, M;
uniform vec2 texRepeat;
in vec3 pos, nor, tan;
in vec2 uv;

out jit_PerVertex {	
	smooth vec3 nor;
	smooth vec3 tan;
	smooth vec3 bit;
	smooth vec3 pos;
	smooth vec2 uv;
} jit_out;

void main() {	
	gl_Position = MVP * vec4(pos, 1.);	
	jit_out.nor = (M * vec4(nor, 0.)).xyz;
	jit_out.tan = (M * vec4(tan, 0.)).xyz;
	jit_out.bit = (M * vec4(cross(nor, tan), 0.)).xyz;
	jit_out.pos = (M * vec4(pos, 1.)).xyz;
	jit_out.uv = uv*texRepeat;
}
]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[
#version 330 core
#define PI 3.14159265

uniform vec3 eye;
uniform mat3 NM;
uniform sampler2D albedoTex, roughnessTex, metallicTex, normalTex, aoTex;
uniform samplerCube irradianceTex;

in jit_PerVertex {
	smooth vec3 nor;
	smooth vec3 tan;
	smooth vec3 bit;
	smooth vec3 pos;
	smooth vec2 uv;
} jit_in;

out vec4 col;

vec3 	lin2sRGB(vec3 x){ return pow(x, vec3(0.4545454545));}
vec3 	sRGB2lin(vec3 x){ return pow(x, vec3(2.2));}
float 	saturate(float x){ return clamp(x, 0., 1.);}
vec3 	saturate3(vec3 x){ return clamp(x, vec3(0.), vec3(1.));}

vec3 fresnelSchlick(float HdotV, vec3 F0){
	//Fresnel Schlick approximation
	float 	x = saturate(1. - HdotV); //x^5
	float 	x2 = x*x;
			x2 *= x2;
			x *= x2;
    return 	F0 + (1. - F0) * x;
} 
float DistributionGGX(float NdotH, float rou){
			rou *= rou; //Disney trick!
			rou *= rou; //roughness^4
     		NdotH *= NdotH; //square the dot product
    float 	denom = (NdotH * (rou - 1.0) + 1.0);
    		denom *= denom;
    		denom *= PI;
	
    return 	rou / denom;
}
float GeometrySchlickGGX(float NdotV, float rou){
			rou += 1.;
    float 	k = (rou*rou) / 8.0; //Disney trick again...
    return NdotV / ( NdotV * (1.0 - k) + k );
}
float GeometrySmith(float NdotV, float NdotL, float rou){
    float ggx2  = GeometrySchlickGGX(NdotV, rou);
    float ggx1  = GeometrySchlickGGX(NdotL, rou);
	
    return ggx1 * ggx2;
} 
vec3 getRadiance(vec3 V, vec3 N, vec3 lig, vec3 ligCol, vec3 pos, vec3 alb, float rou, float met){

	vec3	L = normalize(lig - pos);				//light direction
	vec3	H = normalize(V + L);					//half vector
	float	ligDis = length(lig - pos);		
	float	att = 1. / (ligDis*ligDis);				//light attenuation
	vec3	rad = ligCol * att;						//radiance

	//compute dot products
	float	HdotV = max( dot(H, V), 0.);
    float 	NdotV = max( dot(N, V), 0.);
    float 	NdotL = max( dot(N, L), 0.);
    float   NdotH = max( dot(N, H), 0.);

	vec3 	F0 	= vec3(0.04); 						//dialettric F0
			F0 	= mix(F0, alb, vec3(met));			//use alb as F0 if metallic
	vec3 	F  	= fresnelSchlick(HdotV, F0); 		//compute fresnel
	float	NDF = DistributionGGX(NdotH, rou);   	//compute NDF term
	float 	G   = GeometrySmith(NdotV, NdotL, rou); //compute G term   
	vec3 	spe = (NDF*G*F)/(4.*NdotV*NdotL+0.0001);  

	vec3 	kS = F;					//k specular
	vec3 	kD = vec3(1.0) - kS;	//k diffuse
			kD *= 1.0 - met;		//nullify k diffuse if metallic

	return 	(kD * alb / PI + spe) * rad * NdotL;
}
vec3 ACES(vec3 x){	
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return saturate3((x*(a*x+b))/(x*(c*x+d)+e));
}
void main() {

	vec3	pos = jit_in.pos;						//world position
	vec3 	nor = normalize(jit_in.nor);			//world normals
	vec3 	tan = normalize(jit_in.tan);			//world tangents
	vec3 	bit = normalize(jit_in.bit);			//world bitangent
	mat3 	TBN = mat3(tan, bit, nor);				//TBN matrix

	vec2 	uv 	= jit_in.uv;						//texture coordinates
	vec3 	alb = texture(albedoTex, uv).rgb;		//albedo color
			alb = sRGB2lin(alb);			
	float	rou = texture(roughnessTex, uv).r;		//roughness
	float	met = texture(metallicTex, uv).r;		//metallic
	float	occ = texture(aoTex, uv).r;				//ambient occlusion

	vec3	V = normalize(eye - pos);				//view direction
	vec3	N = texture(normalTex, uv).rgb; 		//normals
			N = normalize(TBN * (N*2. - vec3(1.)));

	vec3	lin = vec3(0.);							//initialize the out color to 0

	//lighting
	{
		vec3	lig = vec3(1., 3., 0.);					//light position
		vec3	ligCol = vec3(1.)*9.;						//light color
				lin += getRadiance(V, N, lig, ligCol, pos, alb, rou, met); //get radiance for this light
	}
	{
		vec3	lig = vec3(-2., 1., -1.);					//light position
		vec3	ligCol = vec3(0.8, 0.5, 0.1)*9.;				//light color
				lin += getRadiance(V, N, lig, ligCol, pos, alb, rou, met); //get radiance for this light
	}
	{
		vec3	lig = vec3(2., -1., 1.);					//light position
		vec3	ligCol = vec3(0.1, 0.5, 0.9)*9.;				//light color
				lin += getRadiance(V, N, lig, ligCol, pos, alb, rou, met); //get radiance for this light
	}
	{
		vec3	lig = vec3(-2., -1., -2.);					//light position
		vec3	ligCol = vec3(1.)*9.;				//light color
				lin += getRadiance(V, N, lig, ligCol, pos, alb, rou, met); //get radiance for this light
	}

	vec3 	F0 	= vec3(0.04); 						//dialettric F0
			F0 	= mix(F0, alb, vec3(met));			//use alb as F0 if metallic
	vec3 	kS = fresnelSchlick(max(dot(N, V), 0.0), F0);
	vec3 	kD = vec3(1.) - kS;
	vec3 	irradiance = texture(irradianceTex, N).rgb;
	vec3 	diffuse    = irradiance * alb;
	vec3 	ambient    = (kD * diffuse) * occ; 
			//lin += ambient;

			lin /= lin + vec3(1.); 		//from HDI lo LDI
			//lin = ACES(lin);
			col.rgb = lin2sRGB(lin);	//gamma correction
			col.a = 1.;
			//col.rgb = N;
}	
]]>
		</program>
	</language>
</jittershader>
